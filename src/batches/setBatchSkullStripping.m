% (C) Copyright 2020 CPP BIDS SPM-pipeline developers

function matlabbatch = setBatchSkullStripping(matlabbatch, BIDS, subID, opt)
  %
  % Creates a batch to computes a brain mask based on the tissue probability maps
  % from the segmentaion.
  %
  % USAGE::
  %
  %   matlabbatch = setBatchSkullStripping(matlabbatch, BIDS, subID, opt)
  %
  % :param matlabbatch: list of SPM batches
  % :type matlabbatch: structure
  % :param BIDS: dataset layout returned by getData
  % :type BIDS: structure
  % :param subID: subject ID
  % :type subID: string
  % :param opt: options
  % :type opt: structure
  %
  % :returns: - :matlabbatch: (structure)
  %
  % This function will get its inputs from the segmentation batch by reading
  % the dependency from ``opt.orderBatches.segment``. If this field is not specified it will
  % try to get the results from the segmentation by relying on the ``anat``
  % image returned by ``getAnatFilename``.
  %
  % The threshold for inclusion in the mask can be set by::
  %
  %   opt.skullstrip.threshold
  %
  % The defaukt is ``0.75``.
  %
  % Any voxel with p(grayMatter) +  p(whiteMatter) + p(CSF) > threshold
  % will be included in the skull stripping mask.
  %

  fprintf(1, ' BUILDING SPATIAL JOB : SKULL STRIPPING\n');

  [anatImage, anatDataDir] = getAnatFilename(BIDS, subID, opt);

  % if this is part of a pipeline we get the segmentation dependency to get
  % the input from.
  % Otherwise the files to process are stored in a cell
  if isfield(opt, 'orderBatches') && isfield(opt.orderBatches, 'segment')

    matlabbatch{end + 1}.spm.util.imcalc.input(1) = ...
        cfg_dep( ...
                'Segment: Bias Corrected (1)', ...
                substruct( ...
                          '.', 'val', '{}', {opt.orderBatches.segment}, ...
                          '.', 'val', '{}', {1}, ...
                          '.', 'val', '{}', {1}), ...
                substruct( ...
                          '.', 'channel', '()', {1}, ...
                          '.', 'biascorr', '()', {':'}));
    matlabbatch{end}.spm.util.imcalc.input(2) = ...
        cfg_dep( ...
                'Segment: c1 Images', ...
                substruct( ...
                          '.', 'val', '{}', {opt.orderBatches.segment}, ...
                          '.', 'val', '{}', {1}, ...
                          '.', 'val', '{}', {1}), ...
                substruct( ...
                          '.', 'tiss', '()', {1}, ...
                          '.', 'c', '()', {':'}));
    matlabbatch{end}.spm.util.imcalc.input(3) = ...
        cfg_dep( ...
                'Segment: c2 Images', ...
                substruct( ...
                          '.', 'val', '{}', {opt.orderBatches.segment}, ...
                          '.', 'val', '{}', {1}, ...
                          '.', 'val', '{}', {1}), ...
                substruct( ...
                          '.', 'tiss', '()', {2}, ...
                          '.', 'c', '()', {':'}));
    matlabbatch{end}.spm.util.imcalc.input(4) = ...
        cfg_dep( ...
                'Segment: c3 Images', ...
                substruct( ...
                          '.', 'val', '{}', {opt.orderBatches.segment}, ...
                          '.', 'val', '{}', {1}, ...
                          '.', 'val', '{}', {1}), ...
                substruct( ...
                          '.', 'tiss', '()', {3}, ...
                          '.', 'c', '()', {':'}));
  else

    % bias corrected image
    biasCorrectedAnatImage = validationInputFile(anatDataDir, anatImage, 'm');
    matlabbatch{end + 1}.spm.util.imcalc.input(1) = biasCorrectedAnatImage;

    % get the tissue probability maps in native space for that subject
    TPMs = validationInputFile(anatDataDir, anatImage, 'c[123]');

    % grey matter
    matlabbatch{end}.spm.util.imcalc.input(2) = TPMs(1, :);
    % white matter
    matlabbatch{end}.spm.util.imcalc.input(3) = TPMs(2, :);
    % csf
    matlabbatch{end}.spm.util.imcalc.input(4) = TPMs(3, :);

  end

  matlabbatch{end}.spm.util.imcalc.output = ['m' strrep(anatImage, '.nii', '_skullstripped.nii')];
  matlabbatch{end}.spm.util.imcalc.outdir = {anatDataDir};

  matlabbatch{end}.spm.util.imcalc.expression = sprintf( ...
                                                        'i1.*((i2+i3+i4)>%f)', ...
                                                        opt.skullstrip.threshold);

  % add a batch to output the mask
  matlabbatch{end + 1} = matlabbatch{end};
  matlabbatch{end}.spm.util.imcalc.expression = sprintf( ...
                                                        '(i2+i3+i4)>%f', ...
                                                        opt.skullstrip.threshold);
  matlabbatch{end}.spm.util.imcalc.output = ['m' strrep(anatImage, '.nii', '_mask.nii')];

end
